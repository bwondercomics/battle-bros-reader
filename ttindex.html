<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5" />
<title>Battle Bros - Free Online Comic Reader | Read Battle Bros Comics</title>
<meta name="description" content="Read Battle Bros comics online for free! Enjoy smooth page transitions, zoom features, and a retro cyberpunk aesthetic. Perfect for mobile and desktop reading." />
<meta name="keywords" content="battle bros, comic reader, online comics, free comics, webcomic, manga reader" />
<meta name="author" content="Battle Bros Comics" />
<meta name="theme-color" content="#00d9ff" />

<!-- Open Graph / Facebook -->
<meta property="og:type" content="website" />
<meta property="og:url" content="https://battlebros.com/" />
<meta property="og:title" content="Battle Bros - Free Online Comic Reader" />
<meta property="og:description" content="Read Battle Bros comics online for free! Enjoy smooth page transitions, zoom features, and a retro cyberpunk aesthetic." />
<meta property="og:image" content="https://battlebros.com/banner1.png" />

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image" />
<meta property="twitter:url" content="https://battlebros.com/" />
<meta property="twitter:title" content="Battle Bros - Free Online Comic Reader" />
<meta property="twitter:description" content="Read Battle Bros comics online for free! Enjoy smooth page transitions, zoom features, and a retro cyberpunk aesthetic." />
<meta property="twitter:image" content="https://battlebros.com/banner1.png" />

<!-- Favicons -->
<link rel="icon" type="image/png" sizes="32x32" href="panel.png" />
<link rel="apple-touch-icon" href="panel.png" />
<link rel="manifest" href="manifest.json" />

<!-- Performance optimizations -->
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link href="https://fonts.googleapis.com/css2?family=Righteous&family=Bebas+Neue&display=swap" rel="stylesheet" />

<!-- Schema.org structured data for SEO -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebSite",
  "name": "Battle Bros Comic Reader",
  "url": "https://battlebros.com/",
  "description": "Free online comic reader featuring the Battle Bros comic series with smooth navigation and retro cyberpunk design.",
  "potentialAction": {
    "@type": "ReadAction",
    "target": "https://battlebros.com/"
  }
}
</script>

<style>
/* ==================== CSS VARIABLES ==================== */
:root {
  --primary: #00d9ff;
  --secondary: #ff00ea;
  --accent: #ffed00;
  --bg-dark: #0a0a12;
  --bg-panel: #1a1a2e;
  --text: #ffffff;
  --danger: #ff3838;
}

/* ==================== RESET ==================== */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

/* ==================== ANIMATIONS ==================== */
@keyframes glitchText {
  0%, 100% { text-shadow: 2px 2px 0 var(--primary), -2px -2px 0 var(--secondary); }
  25% { text-shadow: -2px 2px 0 var(--secondary), 2px -2px 0 var(--primary); }
  50% { text-shadow: 2px -2px 0 var(--primary), -2px 2px 0 var(--secondary); }
  75% { text-shadow: -2px -2px 0 var(--secondary), 2px 2px 0 var(--primary); }
}

@keyframes scanline {
  0% { transform: translateY(-100%); }
  100% { transform: translateY(100%); }
}

@keyframes neonPulse {
  0%, 100% { box-shadow: 0 0 5px var(--primary), 0 0 10px var(--primary); }
  50% { box-shadow: 0 0 10px var(--primary), 0 0 20px var(--primary); }
}

@keyframes pixelShift {
  0%, 100% { transform: translate(0, 0); }
  25% { transform: translate(2px, 0); }
  50% { transform: translate(0, 2px); }
  75% { transform: translate(-2px, 0); }
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* ==================== BASE LAYOUT ==================== */
html, body {
  height: 100%;
  font-family: 'Righteous', sans-serif;
  background: var(--bg-dark);
  color: var(--text);
  -webkit-font-smoothing: antialiased;
}

/* Background effects */
body::before {
  content: "";
  position: fixed;
  inset: 0;
  background: 
    repeating-linear-gradient(0deg, rgba(0,217,255,0.03) 0px, transparent 2px),
    radial-gradient(circle at 20% 80%, rgba(0,217,255,0.06), transparent 40%),
    radial-gradient(circle at 80% 20%, rgba(255,0,234,0.06), transparent 40%);
  pointer-events: none;
  z-index: 0;
}

body::after {
  content: "";
  position: fixed;
  inset: 0;
  background: linear-gradient(transparent 50%, rgba(0,217,255,0.02) 50%);
  background-size: 100% 4px;
  pointer-events: none;
  z-index: 1;
  animation: scanline 8s linear infinite;
  opacity: 0.28;
}

/* ==================== HEADER ==================== */
header.topbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 20px;
  background: linear-gradient(135deg, rgba(10,10,18,0.95), rgba(26,26,46,0.95));
  border-bottom: 3px solid var(--primary);
  position: sticky;
  top: 0;
  z-index: 60;
  backdrop-filter: blur(8px);
}

.brand {
  display: flex;
  gap: 12px;
  align-items: center;
}

.logo {
  width: 50px;
  height: 50px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, var(--bg-panel), var(--bg-dark));
  border: 3px solid var(--primary);
  color: var(--primary);
  font-family: 'Bebas Neue';
  font-weight: 900;
  font-size: 28px;
  box-shadow: 0 0 10px rgba(0,217,255,0.12);
  transition: transform 0.25s;
  animation: neonPulse 6s ease-in-out infinite;
}

.logo:hover {
  transform: scale(1.06);
  animation: glitchText 8s infinite;
}

.title h1 {
  margin: 0;
  font-size: 28px;
  letter-spacing: 6px;
  text-transform: uppercase;
  background: linear-gradient(90deg, var(--primary), var(--secondary), var(--accent));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  filter: drop-shadow(0 0 8px rgba(0,217,255,0.35));
  animation: pixelShift 12s linear infinite, glitchText 8s ease-in-out infinite;
}

.title .subtitle {
  margin: 0;
  font-size: 10px;
  color: var(--accent);
  letter-spacing: 2px;
  opacity: 1;
}

/* ==================== CHAPTER SELECT ==================== */
select#chapter {
  background: linear-gradient(135deg, rgba(0,217,255,0.1), rgba(255,0,234,0.1));
  color: var(--accent);
  border: 2px solid var(--accent);
  padding: 8px 14px;
  clip-path: polygon(6px 0%, 100% 0%, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0% 100%, 0% 6px);
  min-width: 160px;
  font-size: 13px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  text-transform: uppercase;
  font-family: 'Righteous', sans-serif;
}

select#chapter:hover {
  background: linear-gradient(135deg, rgba(0,217,255,0.2), rgba(255,0,234,0.2));
  box-shadow: 0 0 15px rgba(0,217,255,0.5);
}

select#chapter option {
  background: var(--bg-panel);
  color: var(--text);
}

/* ==================== VIEWER LAYOUT ==================== */
.viewerWrap {
  display: flex;
  gap: 12px;
  align-items: stretch;
  justify-content: center;
  width: 100%;
  max-width: 2000px;
  margin: 16px auto;
  padding: 0 12px;
}

/* ==================== SIDE PANELS ==================== */
.side-panel {
  width: 579px;
  min-height: 520px;
  background: linear-gradient(135deg, rgba(26,26,46,0.8), rgba(10,10,18,0.8));
  border: 3px solid var(--primary);
  border-radius: 8px;
  /* padding: 12px; */
  color: var(--text);
  overflow: hidden;
  z-index: 10;
}

.side-panel .preview {
  width: 90%;
  height: 100%;
  display: flex;
  /* align-items: center; */
  justify-content: center;
  /* padding: 6px; */
  background: transparent;
}

.side-panel .preview .panel-preview-img {
  width: 111%;
  height: auto;
  /* max-height: 440px; */
  object-fit: contain;
  display: block;
  border-radius: 6px;
  box-shadow: 0 8px 20px rgba(0,0,0,0.5);
  border: 1px solid rgba(255,255,255,0.02);
}

/* ==================== VIEWPORT ==================== */
.viewport {
  flex: 1 1 auto;
  min-height: 70vh;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  background: linear-gradient(135deg, rgba(26,26,46,0.6), rgba(10,10,18,0.8));
  border: 3px solid var(--primary);
  box-shadow: 0 0 30px rgba(0,217,255,0.12);
  overflow: hidden;
  touch-action: none;
  z-index: 5;
}

/* Fullscreen mode */
body.fullscreen-active .viewport {
  position: fixed !important;
  inset: 0 !important;
  width: 100vw !important;
  height: 100vh !important;
  clip-path: none !important;
  border: none !important;
  margin: 0 !important;
  padding: 0 !important;
  box-shadow: none !important;
  background: #000;
  z-index: 200;
}

body.fullscreen-active .side-panel {
  display: none !important;
}

/* ==================== STAGE & PAGES ==================== */
.stageWrap {
  position: relative;
  width: 100%;
  height: 100%;
  overflow: hidden;
  will-change: transform;
  z-index: 6;
}

.stage {
  display: flex;
  gap: 6px;
  align-items: center;
  justify-content: center;
  transform-origin: 50% 50%;
  will-change: transform;
  cursor: grab;
  touch-action: none;
}

.page {
  display: flex;
  align-items: center;
  justify-content: center;
  background: #000;
  position: relative;
  overflow: hidden;
  border: 2px solid rgba(0,217,255,0.06);
  max-width: 100%;
}

.page img {
  display: block;
  max-width: 100%;
  max-height: 94vh;
  object-fit: contain;
  -webkit-user-drag: none;
  pointer-events: none;
  user-select: none;
}

.spinner {
  position: absolute;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: 3px solid transparent;
  border-top: 3px solid var(--primary);
  border-right: 3px solid var(--secondary);
  animation: spin 0.9s linear infinite;
}

/* ==================== PAGE TRANSITIONS ==================== */
.flashOverlay {
  pointer-events: none;
  position: absolute;
  inset: 0;
  background: #000;
  opacity: 0;
  transition: opacity 140ms linear;
  z-index: 25;
}

.slide-out-left {
  transition: transform 160ms cubic-bezier(0.2, 0.9, 0.2, 1);
  transform: translateX(-18px);
}

.slide-out-right {
  transition: transform 160ms cubic-bezier(0.2, 0.9, 0.2, 1);
  transform: translateX(18px);
}

.slide-in-left {
  transition: transform 200ms cubic-bezier(0.2, 0.9, 0.2, 1);
  transform: translateX(0);
}

.slide-in-right {
  transition: transform 200ms cubic-bezier(0.2, 0.9, 0.2, 1);
  transform: translateX(0);
}

/* ==================== EDGE ZONES ==================== */
.edgeZone {
  position: absolute;
  top: 0;
  height: 100%;
  width: 12%;
  z-index: 30;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  opacity: 0;
  transition: opacity 120ms;
}

.edgeZone.active {
  pointer-events: auto;
  opacity: 1;
}

.edgeZone.left {
  left: 0;
}

.edgeZone.right {
  right: 0;
}

.edgeArrow {
  width: 56px;
  height: 56px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, rgba(0,217,255,0.08), rgba(255,0,234,0.06));
  border: 2px solid rgba(0,217,255,0.12);
  color: var(--primary);
  cursor: pointer;
  user-select: none;
}

/* ==================== CONTROLS ==================== */
.controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  padding: 12px;
  background: linear-gradient(135deg, rgba(26,26,46,0.9), rgba(10,10,18,0.9));
  border: 3px solid var(--primary);
  clip-path: polygon(12px 0%, 100% 0%, 100% calc(100% - 12px), calc(100% - 12px) 100%, 0% 100%, 0% 12px);
  z-index: 70;
  box-shadow: 0 0 20px rgba(0,217,255,0.12);
}

.controls .left,
.controls .right {
  display: flex;
  gap: 8px;
  align-items: center;
}

.btn {
  height: 44px;
  min-width: 44px;
  padding: 0 14px;
  border: 2px solid var(--primary);
  background: linear-gradient(135deg, rgba(0,217,255,0.06), rgba(255,0,234,0.04));
  color: var(--text);
  cursor: pointer;
  font-family: 'Bebas Neue';
  font-weight: 900;
  text-transform: uppercase;
}

.btn.primary {
  font-size: 16px;
  line-height: 1;
  padding: 6px 18px;
  border: none;
  color: var(--bg-dark);
  background-image:
    linear-gradient(180deg, var(--primary) 0%, var(--secondary) 100%),
    repeating-linear-gradient(45deg, rgba(255,255,255,0.06) 0 3px, rgba(255,255,255,0.00) 3px 6px);
  background-blend-mode: overlay;
  box-shadow: 0 0 20px rgba(0,217,255,0.8);
  border-radius: 6px;
  position: relative;
  overflow: hidden;
}

/* Fullscreen control positioning */
body.fullscreen-active header.topbar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 210;
  transition: transform 0.28s ease, opacity 0.28s ease;
  will-change: transform, opacity;
  background: linear-gradient(135deg, rgba(10,10,18,0.9), rgba(26,26,46,0.9));
}

body.fullscreen-active .controls {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 210;
  transition: transform 0.28s ease, opacity 0.28s ease;
  will-change: transform, opacity;
}

body.fullscreen-active header.topbar.hidden {
  transform: translateY(-110%);
  opacity: 0;
}

body.fullscreen-active .controls.hidden {
  transform: translateX(-50%) translateY(110%);
  opacity: 0;
}

/* ==================== STATUS & PROGRESS ==================== */
.status {
  padding: 6px 12px;
  background: linear-gradient(135deg, rgba(255,237,0,0.08), rgba(255,237,0,0.04));
  border: 2px solid var(--accent);
  color: var(--accent);
  font-family: 'Bebas Neue';
  font-weight: 900;
  text-transform: uppercase;
}

.progress-bar {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: rgba(0,217,255,0.12);
  z-index: 50;
}

.progress-fill {
  height: 100%;
  width: 0%;
  transition: width 0.28s ease-out;
  background: linear-gradient(90deg, var(--primary), var(--secondary), var(--accent));
  box-shadow: 0 0 8px rgba(0,217,255,0.08);
}

/* ==================== RESPONSIVE ==================== */
/* Respect user's motion preferences */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
  
  body::after {
    animation: none;
  }
  
  .logo {
    animation: none;
  }
  
  .title h1 {
    animation: none;
  }
}

/* Better keyboard focus indicators */
button:focus-visible,
select:focus-visible,
a:focus-visible,
.viewport:focus-visible {
  outline: 3px solid var(--accent);
  outline-offset: 2px;
}

/* Skip to content link for accessibility */
.skip-to-content {
  position: absolute;
  top: -40px;
  left: 0;
  background: var(--accent);
  color: var(--bg-dark);
  padding: 8px 16px;
  text-decoration: none;
  font-weight: bold;
  z-index: 1000;
  border-radius: 0 0 4px 0;
}

.skip-to-content:focus {
  top: 0;
}

@media (max-width: 900px) {
  .viewerWrap {
    flex-direction: column;
  }
  
  .side-panel {
    width: 100%;
    min-height: 140px;
    display: flex;
    flex-direction: row;
    gap: 8px;
    align-items: center;
    padding: 8px;
  }
  
  .edgeZone {
    width: 18%;
  }
}
</style>
</head>
<body>

<!-- Skip to content link for accessibility -->
<a href="#viewport" class="skip-to-content">Skip to comic</a>

<!-- ==================== HEADER ==================== -->
<header class="topbar" id="topbar">
  <div class="brand">
    <div class="logo">BWC</div>
    <div class="title">
      <h1>BATTLE BROS</h1>
      <p class="subtitle" id="subtitle" aria-live="polite">/// GUESS WHO'S BACK IN TOWN? ///</p>
    </div>
  </div>
  <select id="chapter" aria-label="Select chapter"></select>
</header>

<!-- ==================== MAIN VIEWER ==================== -->
<main>
  <div class="viewerWrap">

    <!-- Left Preview Panel -->
    <aside class="side-panel left" id="leftPanel">
      <div class="preview" id="leftPreview" aria-hidden="false">
        <picture>
          <source srcset="panel.png" type="image/webp">
          <img class="panel-preview-img" src="panel.png" alt="Left illustration preview">
        </picture>
      </div>
    </aside>

    <!-- Main Viewport -->
    <section class="viewport" id="viewport" tabindex="0" aria-label="Comic viewport">
      <div class="stageWrap" id="stageWrap">
        <div class="stage" id="stage">
          
          <!-- Left Page -->
          <div class="page" id="leftPage" role="img" aria-hidden="false">
            <div class="spinner" id="leftSpinner" style="display:none;"></div>
            <img id="leftImg" src="" alt="" draggable="false" loading="lazy">
          </div>

          <!-- Right Page (two-page mode) -->
          <div class="page" id="rightPage" aria-hidden="true" style="display:none;">
            <div class="spinner" id="rightSpinner" style="display:none;"></div>
            <img id="rightImg" src="" alt="" draggable="false" loading="lazy">
          </div>
        </div>

        <div class="flashOverlay" id="flashOverlay" aria-hidden="true"></div>
      </div>

      <!-- Edge Navigation Zones -->
      <div class="edgeZone left" id="edgeLeft" aria-hidden="true">
        <div class="edgeArrow" id="edgeLeftBtn" title="Previous page" role="button" aria-label="Previous page">
          <svg viewBox="0 0 24 24" width="22" height="22"><path fill="currentColor" d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>
        </div>
      </div>
      <div class="edgeZone right" id="edgeRight" aria-hidden="true">
        <div class="edgeArrow" id="edgeRightBtn" title="Next page" role="button" aria-label="Next page">
          <svg viewBox="0 0 24 24" width="22" height="22"><path fill="currentColor" d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6z"/></svg>
        </div>
      </div>

      <!-- Progress Bar -->
      <div class="progress-bar" aria-hidden="true">
        <div class="progress-fill" id="progressFill"></div>
      </div>
    </section>

    <!-- Right Preview Panel -->
    <aside class="side-panel right" id="rightPanel">
      <div class="preview" id="rightPreview" aria-hidden="false">
        <picture>
          <source srcset="banner3.png" type="image/webp">
          <img class="panel-preview-img" src="banner3.png" alt="Right illustration preview">
        </picture>
      </div>
    </aside>

  </div>

  <!-- ==================== CONTROLS ==================== -->
  <div class="controls" id="controls" role="toolbar" aria-label="Reader controls">
    <div class="left">
      <button class="btn" id="prevBtn" type="button" aria-label="Previous page">◀ BACK</button>
      <button class="btn" id="nextBtn" type="button" aria-label="Next page">NEXT ▶</button>
      <span class="status" id="pageIndicator" aria-live="polite">PAGE 0 / 0</span>
    </div>
    <div class="right">
      <button class="btn" id="zoomOut" type="button" aria-label="Zoom out">−</button>
      <button class="btn primary" id="fitBtn" type="button" aria-label="Fit">⚡ FIT</button>
      <button class="btn" id="zoomIn" type="button" aria-label="Zoom in">+</button>
      <button class="btn" id="fullscreenBtn" type="button" aria-label="Toggle fullscreen">⛶</button>
    </div>
  </div>
</main>

<script>
(function() {
  'use strict';

  // ==================== CONFIGURATION ====================
  const CONFIG = {
    STORAGE_KEY: 'battleBros_progress',
    IMAGE_CACHE_SIZE: 60,
    PRELOAD_AHEAD: 8,
    TWO_PAGE_BREAKPOINT: 900,
    ZOOM_STEP: 1.2,
    ZOOM_MIN: 0.05,
    ZOOM_MAX: 20,
    ANIMATION_DURATION: 200,
    CONTROLS_HIDE_DELAY: 1200,
    EDGE_ZONE_THRESHOLD: 0.12,
    SWIPE_THRESHOLD: 50,
    SWIPE_TIMEOUT: 500
  };

  // ==================== CHAPTER DATA ====================
  const chapters = {
    "Chapter 1": ["chapters/01/01.png","chapters/01/02.png","chapters/01/03.png","chapters/01/04.png","chapters/01/05.png","chapters/01/06.png","chapters/01/07.png","chapters/01/08.png","banner1.png","banner2.png"],
    "Chapter 2": ["chapters/02/01.png","chapters/02/02.png","chapters/02/03.png","chapters/02/04.png","chapters/02/05.png","chapters/02/06.png","chapters/02/07.png","chapters/02/08.png"],
    "Chapter 3": ["chapters/03/01.png","chapters/03/02.png","chapters/03/03.png","chapters/03/04.png","chapters/03/05.png","chapters/03/06.png","chapters/03/07.png","chapters/03/08.png","chapters/03/09.png","chapters/03/10.png","chapters/03/11.png","chapters/03/12.png","chapters/03/13.png","chapters/03/14.png","end.png"],
    "Chapter 4": ["chapters/04/01.png","chapters/04/02.png","chapters/04/03.png","chapters/04/04.png","chapters/04/05.png","chapters/04/06.png","chapters/04/07.png","chapters/04/08.png","chapters/04/09.png","chapters/04/10.png"],
    "Chapter 5": ["chapters/05/01.png","chapters/05/02.png","chapters/05/03.png","chapters/05/04.png","chapters/05/05.png","chapters/05/06.png","chapters/05/07.png","chapters/05/08.png","chapters/05/09.png","chapters/05/10.png","chapters/05/11.png","chapters/05/12.png","chapters/05/13.png","chapters/05/14.png","chapters/05/15.png"],
    "Chapter 6": ["chapters/06/01.png","chapters/06/02.png","chapters/06/03.png","chapters/06/04.png","chapters/06/05.png","chapters/06/06.png","chapters/06/07.png","chapters/06/08.png","chapters/06/09.png","chapters/06/10.png","chapters/06/11.png","chapters/06/12.png","chapters/06/13.png","chapters/06/14.png","chapters/06/15.png"],
    "Chapter 7": ["chapters/07/01.png","chapters/07/02.png","chapters/07/03.png","chapters/07/04.png","chapters/07/05.png","chapters/07/06.png","chapters/07/07.png","chapters/07/08.png","chapters/07/09.png","chapters/07/10.png","chapters/07/11.png","chapters/07/12.png","chapters/07/13.png","chapters/07/14.png","chapters/07/15.png"],
    "Chapter 8": ["chapters/08/01.png","chapters/08/02.png","chapters/08/03.png","chapters/08/04.png","chapters/08/05.png","chapters/08/06.png","chapters/08/07.png","chapters/08/08.png","chapters/08/09.png","chapters/08/10.png","chapters/08/11.png","chapters/08/12.png","chapters/08/13.png","chapters/08/14.png","chapters/08/15.png"],
    "Chapter 9": ["chapters/09/01.png","chapters/09/02.png","chapters/09/03.png","chapters/09/04.png","chapters/09/05.png","chapters/09/06.png","chapters/09/07.png","chapters/09/08.png","chapters/09/09.png","chapters/09/10.png","chapters/09/11.png","chapters/09/12.png","chapters/09/13.png","chapters/09/14.png","chapters/09/15.png"]
  };

  // ==================== QUOTES ====================
  // Edit or extend this list of quotes as needed
  const QUOTES = [
     "/// GUESS WHO'S BACK IN TOWN? (IT'S THE BROS) ///",
    "/// LIKE A BATTLE ROYAL BUT MORE FUN ///",
    "/// DRAGON BALL Z ABRIDGED IS COOL ///",
    "/// SINGLE SMACK GUY ///",
    "/// MAOI SAMI POW! ///",
    "/// NOW WITH 20% ///",
    "/// LITTLE BIDEN ///",
    "/// THAT MEANS NOTHING TO ME ///",
    "/// BATTLE BROS ///",
    "/// DIGIMON THE MOVIE 2000 ///",
	"/// CHINESE CHICKEN ///",
    "/// 9001 ///",
    "/// LOVE THE FIT BUTTON ///",
    "/// YO SAMURAI ///",
    "/// PENISDOTCLOWNFART ///",
    "/// BE LIKE WATER ///",
    "/// PNEUMATICS RULE ///",
    "/// SONICS FRICKS ///",
    "/// I LOVE YOU ///",
	"/// BOUNCE ON A BROTHA ///",
	"/// NOW ON THE 3DS ///",
    "/// EPIC BATTLES AWAIT ///",
    "/// YOUR ADVENTURE STARTS HERE ///"
  ];

  // ==================== STATE ====================
  const state = {
    // Chapter & Pages
    currentChapter: '',
    pages: [],
    pageIndex: 0,
    
    // Zoom & Pan
    scale: 1,
    pan: { x: 0, y: 0 },
    
    // Interaction
    isDragging: false,
    dragStart: { x: 0, y: 0 },
    panStart: { x: 0, y: 0 },
    touchStart: null,
    pointers: new Map(),
    
    // Pinch Zoom
    pinchDistance: null,
    pinchScale: 1,
    pinchCenter: null,
    
    // Performance
    imageCache: new Map(),
    isTransitioning: false,
    rafId: null,
    prevTransformOrigin: null,
    
    // Double Tap
    lastTap: 0
  };

  // ==================== DOM ELEMENTS ====================
  const el = {};

  /**
   * Cache all DOM element references
   */
  function initElements() {
    el.chapter = document.getElementById('chapter');
    el.stageWrap = document.getElementById('stageWrap');
    el.stage = document.getElementById('stage');
    el.viewport = document.getElementById('viewport');
    el.topbar = document.getElementById('topbar');
    el.controls = document.getElementById('controls');
    el.leftPage = document.getElementById('leftPage');
    el.rightPage = document.getElementById('rightPage');
    el.leftImg = document.getElementById('leftImg');
    el.rightImg = document.getElementById('rightImg');
    el.leftSpinner = document.getElementById('leftSpinner');
    el.rightSpinner = document.getElementById('rightSpinner');
    el.indicator = document.getElementById('pageIndicator');
    el.progressFill = document.getElementById('progressFill');
    el.prevBtn = document.getElementById('prevBtn');
    el.nextBtn = document.getElementById('nextBtn');
    el.zoomIn = document.getElementById('zoomIn');
    el.zoomOut = document.getElementById('zoomOut');
    el.fitBtn = document.getElementById('fitBtn');
    el.fullscreenBtn = document.getElementById('fullscreenBtn');
    el.flash = document.getElementById('flashOverlay');
    el.edgeLeft = document.getElementById('edgeLeft');
    el.edgeRight = document.getElementById('edgeRight');
    el.edgeLeftBtn = document.getElementById('edgeLeftBtn');
    el.edgeRightBtn = document.getElementById('edgeRightBtn');
    el.subtitle = document.getElementById('subtitle');
  }

  // ==================== IMAGE LOADING ====================
  
  /**
   * Preload image and cache it
   * @param {string} url - Image URL to preload
   * @returns {Promise<Image>}
   */
  function preloadImage(url) {
    if (!url) return Promise.reject('no-url');
    if (state.imageCache.has(url)) return state.imageCache.get(url);
    
    const promise = new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error('Image load failed: ' + url));
      img.src = url;
    });
    
    state.imageCache.set(url, promise);
    
    // Limit cache size
    if (state.imageCache.size > CONFIG.IMAGE_CACHE_SIZE) {
      const firstKey = state.imageCache.keys().next().value;
      state.imageCache.delete(firstKey);
    }
    
    return promise;
  }

  /**
   * Load image into DOM element with spinner
   * @param {HTMLImageElement} imgEl - Target image element
   * @param {HTMLElement} spinnerEl - Loading spinner element
   * @param {string} url - Image URL to load
   */
  function loadImage(imgEl, spinnerEl, url) {
    if (!imgEl) return;
    
    // Clear image
    if (!url) {
      imgEl.removeAttribute('src');
      imgEl.alt = '';
      if (spinnerEl) spinnerEl.style.display = 'none';
      return;
    }
    
    // Show spinner
    if (spinnerEl) spinnerEl.style.display = '';
    
    // Hide spinner when loaded
    const hideSpinner = () => {
      if (spinnerEl) spinnerEl.style.display = 'none';
      imgEl.removeEventListener('load', hideSpinner);
      imgEl.removeEventListener('error', hideSpinner);
    };
    
    imgEl.addEventListener('load', hideSpinner);
    imgEl.addEventListener('error', hideSpinner);
    
    // Set alt text
    const pageNum = state.pages.indexOf(url) + 1;
    imgEl.alt = `${state.currentChapter} – page ${pageNum}`;
    
    // Load image
    imgEl.src = url;
    
    // Preload in background
    preloadImage(url).catch(() => {});
  }

  /**
   * Preload upcoming pages
   */
  function preloadUpcoming() {
    const startIdx = state.pageIndex + 2;
    const endIdx = Math.min(state.pages.length, startIdx + CONFIG.PRELOAD_AHEAD);
    
    for (let i = startIdx; i < endIdx; i++) {
      preloadImage(state.pages[i]).catch(() => {});
    }
  }

  // ==================== PROGRESS PERSISTENCE ====================
  
  /**
   * Save reading progress to localStorage
   */
  function saveProgress() {
    try {
      const data = {
        chapter: state.currentChapter,
        page: state.pageIndex,
        timestamp: Date.now()
      };
      localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(data));
    } catch (e) {
      console.warn('Failed to save progress:', e);
    }
  }

  /**
   * Load reading progress from localStorage
   * @returns {Object|null}
   */
  function loadProgress() {
    try {
      const json = localStorage.getItem(CONFIG.STORAGE_KEY);
      return json ? JSON.parse(json) : null;
    } catch (e) {
      return null;
    }
  }

  // ==================== LAYOUT HELPERS ====================
  
  /**
   * Check if screen is wide enough for two-page mode
   * @returns {boolean}
   */
  function isTwoPageMode() {
    return window.innerWidth >= CONFIG.TWO_PAGE_BREAKPOINT;
  }

  /**
   * Check if two pages can be displayed
   * @returns {boolean}
   */
  function canShowTwoPages() {
    return isTwoPageMode() && state.pageIndex + 1 < state.pages.length;
  }

  // ==================== RENDERING ====================
  
  /**
   * Render current page(s)
   */
  function render() {
    // Mark as transitioning
    state.isTransitioning = true;
    if (el.stage) el.stage.classList.add('transitioning');
    setTimeout(() => {
      if (el.stage) el.stage.classList.remove('transitioning');
      state.isTransitioning = false;
    }, CONFIG.ANIMATION_DURATION);

    const twoPageMode = canShowTwoPages();
    const leftUrl = state.pages[state.pageIndex] || '';
    const rightUrl = state.pages[state.pageIndex + 1] || '';

    // Single page mode
    if (!twoPageMode) {
      if (el.rightPage) el.rightPage.style.display = 'none';
      loadImage(el.leftImg, el.leftSpinner, leftUrl);
    } 
    // Two page mode
    else {
      if (el.rightPage) el.rightPage.style.display = '';
      loadImage(el.leftImg, el.leftSpinner, leftUrl);
      loadImage(el.rightImg, el.rightSpinner, rightUrl);
    }

    updateUI();
    preloadUpcoming();
  }

  /**
   * Update UI indicators (page counter, buttons, progress bar)
   */
  function updateUI() {
    const total = state.pages.length || 1;
    const current = state.pageIndex + 1;
    const twoPageMode = canShowTwoPages();

    // Page indicator
    if (el.indicator) {
      el.indicator.textContent = twoPageMode
        ? `PAGE ${current}-${Math.min(current + 1, total)} / ${total}`
        : `PAGE ${current} / ${total}`;
    }

    // Progress bar
    if (el.progressFill) {
      const displayed = Math.min(total, state.pageIndex + (twoPageMode ? 2 : 1));
      el.progressFill.style.width = ((displayed / total) * 100) + '%';
    }

    // Navigation buttons
    if (el.prevBtn) {
      el.prevBtn.disabled = state.pageIndex === 0;
    }
    
    if (el.nextBtn) {
      const isAtEnd = state.pageIndex >= total - 1;
      const rightIsLast = twoPageMode && state.pageIndex + 1 === total - 1;
      el.nextBtn.disabled = isAtEnd || rightIsLast;
    }
  }

  // ==================== PAGE NAVIGATION ====================
  
  /**
   * Animate page transition
   * @param {string} direction - 'next' or 'prev'
   * @param {Function} onMid - Callback to run mid-transition
   */
  function animatePageChange(direction, onMid) {
    if (state.isTransitioning) return;
    if (!el.stageWrap) {
      if (typeof onMid === 'function') onMid();
      return;
    }

    state.isTransitioning = true;

    // Reset classes
    el.stageWrap.classList.remove('slide-in-left', 'slide-in-right', 'slide-out-left', 'slide-out-right');
    void el.stageWrap.offsetWidth; // Force reflow

    // Slide out
    const slideOut = direction === 'next' ? 'slide-out-left' : 'slide-out-right';
    el.stageWrap.classList.add(slideOut);

    // Flash effect
    if (el.flash) {
      setTimeout(() => {
        el.flash.style.opacity = '1';
      }, 80);
    }

    // Mid-transition
    setTimeout(() => {
      if (typeof onMid === 'function') onMid();

      // Reset flash
      if (el.flash) {
        el.flash.style.transition = 'opacity 160ms linear';
        el.flash.style.opacity = '0';
      }

      // Slide in
      el.stageWrap.classList.remove('slide-out-left', 'slide-out-right');
      
      if (direction === 'next') {
        el.stageWrap.style.transform = 'translateX(18px)';
        requestAnimationFrame(() => {
          el.stageWrap.classList.add('slide-in-left');
          el.stageWrap.style.transform = 'translateX(0)';
        });
      } else {
        el.stageWrap.style.transform = 'translateX(-18px)';
        requestAnimationFrame(() => {
          el.stageWrap.classList.add('slide-in-right');
          el.stageWrap.style.transform = 'translateX(0)';
        });
      }

      // Cleanup
      setTimeout(() => {
        el.stageWrap.classList.remove('slide-in-left', 'slide-in-right');
        el.stageWrap.style.transform = '';
        state.isTransitioning = false;
      }, 220);
    }, CONFIG.ANIMATION_DURATION);
  }

  /**
   * Navigate to previous page
   */
  function prevPage() {
    if (state.isTransitioning) return;

    const step = isTwoPageMode() ? 2 : 1;
    const newIndex = Math.max(0, state.pageIndex - step);
    
    if (newIndex === state.pageIndex) return;

    animatePageChange('prev', () => {
      state.pageIndex = newIndex;
      render();
      saveProgress();
    });
  }

  /**
   * Navigate to next page
   */
  function nextPage() {
    if (state.isTransitioning) return;

    const twoPageMode = isTwoPageMode();
    const total = state.pages.length;

    // Check if at end
    const rightIsLast = twoPageMode && state.pageIndex + 1 === total - 1;
    const isAtEnd = state.pageIndex >= total - 1;
    
    if (rightIsLast || isAtEnd) {
      // Could show ending card here
      return;
    }

    // Calculate next index
    let newIndex;
    if (twoPageMode) {
      newIndex = state.pageIndex + 2 >= total 
        ? total - 1 
        : state.pageIndex + 2;
    } else {
      newIndex = Math.min(total - 1, state.pageIndex + 1);
    }

    animatePageChange('next', () => {
      state.pageIndex = newIndex;
      render();
      saveProgress();
    });
  }

  // ==================== ZOOM & PAN ====================
  
  /**
   * Apply current transform (scale + pan) to stage
   */
  function applyTransform() {
    if (state.rafId) cancelAnimationFrame(state.rafId);
    
    state.rafId = requestAnimationFrame(() => {
      if (el.stage) {
        el.stage.style.transform = `translate(${state.pan.x}px, ${state.pan.y}px) scale(${state.scale})`;
      }
      state.rafId = null;
    });
  }

  /**
   * Zoom in
   */
  function zoomIn() {
    state.scale = Math.min(CONFIG.ZOOM_MAX, state.scale * CONFIG.ZOOM_STEP);
    applyTransform();
  }

  /**
   * Zoom out
   */
  function zoomOut() {
    state.scale = Math.max(CONFIG.ZOOM_MIN, state.scale / CONFIG.ZOOM_STEP);
    applyTransform();
  }

  /**
   * Reset zoom and pan
   */
  function resetView() {
    state.scale = 1;
    state.pan = { x: 0, y: 0 };
    applyTransform();
  }

  /**
   * Fit to screen (fullscreen: fit height, normal: reset)
   */
  function fitToScreen() {
    if (document.fullscreenElement) {
      fitHeightFullscreen();
    } else {
      resetView();
    }
  }

  /**
   * Fit page height to viewport in fullscreen mode
   */
  function fitHeightFullscreen() {
    const img = el.leftImg;
    if (!img) {
      state.scale = 1;
      applyTransform();
      return;
    }

    // Set transform origin to top
    if (el.stage) {
      if (state.prevTransformOrigin === null) {
        state.prevTransformOrigin = window.getComputedStyle(el.stage).transformOrigin || '50% 50%';
      }
      el.stage.style.transformOrigin = 'top center';
    }

    const vpHeight = el.viewport.clientHeight;

    const doFit = () => {
      const rect = img.getBoundingClientRect();
      const baseHeight = rect.height || img.naturalHeight || img.height || 1;
      let targetScale = vpHeight / baseHeight;
      targetScale = Math.max(CONFIG.ZOOM_MIN, Math.min(CONFIG.ZOOM_MAX, targetScale));
      
      state.scale = targetScale;
      state.pan = { x: 0, y: 0 };
      applyTransform();
    };

    // Reset first, then fit after layout settles
    const prevScale = state.scale;
    const prevPan = { ...state.pan };
    
    state.scale = 1;
    state.pan = { x: 0, y: 0 };
    applyTransform();

    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        try {
          doFit();
        } catch (e) {
          console.error('Fit error:', e);
          state.scale = prevScale;
          state.pan = prevPan;
          applyTransform();
        }
      });
    });
  }

  // ==================== POINTER INTERACTIONS ====================
  
  /**
   * Calculate distance between two points
   */
  function getDistance(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  /**
   * Handle pointer down (mouse/touch start)
   */
  function onPointerDown(e) {
    // Capture pointer
    try {
      e.target.setPointerCapture(e.pointerId);
    } catch (err) {}

    state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
    const pointerCount = state.pointers.size;

    // Single pointer: pan/swipe
    if (pointerCount === 1) {
      state.touchStart = {
        x: e.clientX,
        y: e.clientY,
        time: Date.now()
      };
      state.dragStart = { x: e.clientX, y: e.clientY };
      state.panStart = { ...state.pan };
      state.isDragging = state.scale > 1.01;
    }
    // Two pointers: pinch zoom
    else if (pointerCount === 2) {
      const points = Array.from(state.pointers.values());
      state.pinchDistance = getDistance(points[0], points[1]);
      state.pinchScale = state.scale;
      state.pinchCenter = {
        x: (points[0].x + points[1].x) / 2,
        y: (points[0].y + points[1].y) / 2
      };
      state.panStart = { ...state.pan };
      state.isDragging = false;
    }

    // Show controls in fullscreen
    if (document.fullscreenElement) {
      const nearEdge = e.clientY < 150 || e.clientY > window.innerHeight - 200;
      if (nearEdge) showControlsBar();
    }
  }

  /**
   * Handle pointer move
   */
  function onPointerMove(e) {
    if (!state.pointers.has(e.pointerId)) return;

    state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
    updateEdgeZones(e.clientX, e.clientY);

    const pointerCount = state.pointers.size;

    // Single pointer: pan
    if (pointerCount === 1) {
      if (state.isDragging) {
        const point = Array.from(state.pointers.values())[0];
        state.pan.x = state.panStart.x + (point.x - state.dragStart.x);
        state.pan.y = state.panStart.y + (point.y - state.dragStart.y);
        applyTransform();
      }
    }
    // Two pointers: pinch zoom
    else if (pointerCount >= 2) {
      const points = Array.from(state.pointers.values());
      const newDist = getDistance(points[0], points[1]);
      
      if (state.pinchDistance && state.pinchScale != null) {
        const scale = state.pinchScale * (newDist / state.pinchDistance);
        const newScale = Math.max(CONFIG.ZOOM_MIN, Math.min(CONFIG.ZOOM_MAX, scale));
        
        const newCenter = {
          x: (points[0].x + points[1].x) / 2,
          y: (points[0].y + points[1].y) / 2
        };

        state.scale = newScale;
        state.pan.x = state.panStart.x + (newCenter.x - state.pinchCenter.x);
        state.pan.y = state.panStart.y + (newCenter.y - state.pinchCenter.y);
        applyTransform();
      }
    }
  }

  /**
   * Handle pointer up (mouse/touch end)
   */
  function onPointerUp(e) {
    // Release pointer
    try {
      e.target.releasePointerCapture(e.pointerId);
    } catch (err) {}

    state.pointers.delete(e.pointerId);

    // All pointers released
    if (state.pointers.size === 0) {
      const wasPinching = state.pinchDistance !== null;

      // Detect swipe gesture
      if (!wasPinching && state.touchStart) {
        const dx = e.clientX - state.touchStart.x;
        const dy = e.clientY - state.touchStart.y;
        const dt = Date.now() - state.touchStart.time;

        const isHorizontalSwipe = Math.abs(dx) > CONFIG.SWIPE_THRESHOLD;
        const isDominantlyHorizontal = Math.abs(dx) > Math.abs(dy);
        const isFastEnough = dt < CONFIG.SWIPE_TIMEOUT;
        const isNotZoomed = state.scale <= 1.01;

        if (isHorizontalSwipe && isDominantlyHorizontal && isFastEnough && isNotZoomed) {
          dx > 0 ? prevPage() : nextPage();
        }
      }

      // Reset interaction state
      state.isDragging = false;
      state.touchStart = null;
      state.pinchDistance = null;
      state.pinchCenter = null;
      state.pinchScale = state.scale;
    }
    // One pointer remains: update drag reference
    else if (state.pointers.size === 1) {
      const remaining = Array.from(state.pointers.values())[0];
      state.dragStart = { x: remaining.x, y: remaining.y };
      state.panStart = { ...state.pan };
      state.isDragging = state.scale > 1.01;
    }
  }

  /**
   * Handle mouse wheel (zoom with Ctrl)
   */
  function onWheel(e) {
    if (e.ctrlKey) {
      e.preventDefault();
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      state.scale = Math.max(CONFIG.ZOOM_MIN, Math.min(CONFIG.ZOOM_MAX, state.scale + delta));
      applyTransform();
    }
  }

  // ==================== EDGE ZONES ====================
  
  /**
   * Update edge navigation zones based on pointer position
   */
  function updateEdgeZones(x, y) {
    if (!el.viewport) return;

    // Hide zones when dragging
    if (state.isDragging || state.pointers.size > 0) {
      if (el.edgeLeft) el.edgeLeft.classList.remove('active');
      if (el.edgeRight) el.edgeRight.classList.remove('active');
      if (el.viewport) el.viewport.style.cursor = '';
      return;
    }

    // Calculate position percentage
    const rect = el.viewport.getBoundingClientRect();
    const relX = x - rect.left;
    const pct = relX / rect.width;

    // Show appropriate zone
    if (pct < CONFIG.EDGE_ZONE_THRESHOLD) {
      if (el.edgeLeft) el.edgeLeft.classList.add('active');
      if (el.edgeRight) el.edgeRight.classList.remove('active');
      if (el.viewport) el.viewport.style.cursor = 'pointer';
    } else if (pct > 1 - CONFIG.EDGE_ZONE_THRESHOLD) {
      if (el.edgeRight) el.edgeRight.classList.add('active');
      if (el.edgeLeft) el.edgeLeft.classList.remove('active');
      if (el.viewport) el.viewport.style.cursor = 'pointer';
    } else {
      if (el.edgeLeft) el.edgeLeft.classList.remove('active');
      if (el.edgeRight) el.edgeRight.classList.remove('active');
      if (el.viewport) el.viewport.style.cursor = '';
    }
  }

  // ==================== FULLSCREEN CONTROLS ====================
  
  let hideTimer = null;
  let mouseOverControls = false;

  /**
   * Show controls bar (auto-hide in fullscreen)
   */
  function showControlsBar() {
    if (el.topbar) el.topbar.classList.remove('hidden');
    if (el.controls) el.controls.classList.remove('hidden');

    // Clear existing timer
    if (hideTimer) {
      clearTimeout(hideTimer);
      hideTimer = null;
    }

    // Auto-hide in fullscreen
    if (document.fullscreenElement && !mouseOverControls) {
      hideTimer = setTimeout(() => {
        if (!mouseOverControls) {
          if (el.topbar) el.topbar.classList.add('hidden');
          if (el.controls) el.controls.classList.add('hidden');
        }
      }, CONFIG.CONTROLS_HIDE_DELAY);
    }
  }

  /**
   * Handle fullscreen state change
   */
  function onFullscreenChange() {
    if (document.fullscreenElement) {
      // Entering fullscreen
      document.body.classList.add('fullscreen-active');
      if (el.fullscreenBtn) el.fullscreenBtn.textContent = '✕';
      showControlsBar();

      // Fit to height after layout settles
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          try {
            fitHeightFullscreen();
          } catch (e) {
            console.warn('Fit failed on fullscreen enter:', e);
          }
        });
      });
    } else {
      // Exiting fullscreen
      document.body.classList.remove('fullscreen-active');
      if (el.fullscreenBtn) el.fullscreenBtn.textContent = '⛶';
      if (el.topbar) el.topbar.classList.remove('hidden');
      if (el.controls) el.controls.classList.remove('hidden');

      // Restore transform origin
      if (el.stage && state.prevTransformOrigin !== null) {
        el.stage.style.transformOrigin = state.prevTransformOrigin;
        state.prevTransformOrigin = null;
      }

      if (hideTimer) {
        clearTimeout(hideTimer);
        hideTimer = null;
      }
    }
  }

  /**
   * Toggle fullscreen mode
   */
  function toggleFullscreen() {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().catch(() => {});
    } else {
      document.exitFullscreen();
    }
  }

  // ==================== CHAPTER MANAGEMENT ====================
  
  /**
   * Populate chapter dropdown
   */
  function initChapterSelect() {
    if (!el.chapter) return;

    Object.keys(chapters).forEach(name => {
      const option = document.createElement('option');
      option.value = name;
      option.textContent = name;
      el.chapter.appendChild(option);
    });
  }

  /**
   * Change current chapter
   */
  function changeChapter(chapterName) {
    if (!chapters[chapterName]) return;

    state.currentChapter = chapterName;
    state.pages = chapters[chapterName];
    state.pageIndex = 0;
    state.scale = 1;
    state.pan = { x: 0, y: 0 };
    
    render();
    saveProgress();
  }

  // ==================== EVENT HANDLERS ====================
  
  /**
   * Attach all UI event handlers
   */
  function attachEventHandlers() {
    // Navigation buttons
    if (el.prevBtn) el.prevBtn.addEventListener('click', prevPage);
    if (el.nextBtn) el.nextBtn.addEventListener('click', nextPage);

    // Zoom buttons
    if (el.zoomIn) el.zoomIn.addEventListener('click', zoomIn);
    if (el.zoomOut) el.zoomOut.addEventListener('click', zoomOut);
    if (el.fitBtn) el.fitBtn.addEventListener('click', fitToScreen);
    if (el.fullscreenBtn) el.fullscreenBtn.addEventListener('click', toggleFullscreen);

    // Edge zone navigation
    if (el.edgeLeftBtn) {
      el.edgeLeftBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        prevPage();
      });
    }
    if (el.edgeRightBtn) {
      el.edgeRightBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        nextPage();
      });
    }

    // Pointer events
    if (el.stage) el.stage.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);
    window.addEventListener('pointercancel', onPointerUp);
    if (el.stage) el.stage.addEventListener('wheel', onWheel, { passive: false });

    // Viewport interactions
    if (el.viewport) {
      // Edge zone updates
      el.viewport.addEventListener('mousemove', (e) => {
        updateEdgeZones(e.clientX, e.clientY);
      });

      // Double-tap to fit
      el.viewport.addEventListener('pointerup', (e) => {
        if (!state.isDragging && state.pointers.size === 0) {
          const now = Date.now();
          if (state.lastTap && now - state.lastTap < 300) {
            state.lastTap = 0;
            fitToScreen();
          } else {
            state.lastTap = now;
          }
        }
      });
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      switch (e.key) {
        case 'ArrowLeft':
          e.preventDefault();
          prevPage();
          break;
        case 'ArrowRight':
          e.preventDefault();
          nextPage();
          break;
        case '+':
        case '=':
          e.preventDefault();
          zoomIn();
          break;
        case '-':
          e.preventDefault();
          zoomOut();
          break;
        case '0':
          e.preventDefault();
          resetView();
          break;
        case 'f':
        case 'F':
          e.preventDefault();
          toggleFullscreen();
          break;
      }
    });

    // Fullscreen events
    document.addEventListener('fullscreenchange', onFullscreenChange);

    // Show controls on mouse movement in fullscreen
    document.addEventListener('mousemove', (e) => {
      if (document.fullscreenElement) {
        const nearEdge = e.clientY < 150 || e.clientY > window.innerHeight - 200;
        if (nearEdge) showControlsBar();
      }
    });

    // Control bar hover (prevent auto-hide)
    if (el.topbar) {
      el.topbar.addEventListener('mouseenter', () => {
        mouseOverControls = true;
        if (hideTimer) {
          clearTimeout(hideTimer);
          hideTimer = null;
        }
      });
      el.topbar.addEventListener('mouseleave', () => {
        mouseOverControls = false;
        showControlsBar();
      });
    }

    if (el.controls) {
      el.controls.addEventListener('mouseenter', () => {
        mouseOverControls = true;
        if (hideTimer) {
          clearTimeout(hideTimer);
          hideTimer = null;
        }
      });
      el.controls.addEventListener('mouseleave', () => {
        mouseOverControls = false;
        showControlsBar();
      });
    }

    // Chapter selection
    if (el.chapter) {
      el.chapter.addEventListener('change', (e) => {
        changeChapter(e.target.value);
      });
    }

    // Handle window resize and orientation changes with debouncing
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        render();
      }, 150);
    });
  }

  // ==================== QUOTE ONCE (PAGE LOAD ONLY) ====================

  /**
   * Pick a random index (simple)
   * @returns {number}
   */
  function pickRandomQuoteIndexOnce() {
    if (QUOTES.length === 0) return -1;
    return Math.floor(Math.random() * QUOTES.length);
  }

  /**
   * Set a single random subtitle when the page initializes.
   */
  function setInitialSubtitle() {
    if (!el.subtitle) return;
    const idx = pickRandomQuoteIndexOnce();
    if (idx >= 0) el.subtitle.textContent = QUOTES[idx];
  }

  // ==================== INITIALIZATION ====================
  
  /**
   * Initialize the reader
   */
  function init() {
    // Cache DOM elements
    initElements();

    // Populate chapter dropdown
    initChapterSelect();

    // Set one random subtitle now (only once on load)
    setInitialSubtitle();

    // Load saved progress
    const saved = loadProgress();
    if (saved && chapters[saved.chapter]) {
      state.currentChapter = saved.chapter;
      state.pages = chapters[saved.chapter];
      state.pageIndex = saved.page || 0;
    } else {
      // Default to first chapter
      const firstChapter = Object.keys(chapters)[0];
      state.currentChapter = firstChapter;
      state.pages = chapters[firstChapter] || [];
      state.pageIndex = 0;
    }

    // Set chapter dropdown value
    if (el.chapter) el.chapter.value = state.currentChapter;

    // Attach event handlers
    attachEventHandlers();

    // Initial render
    render();

    console.log('✓ Battle Bros Reader initialized (subtitle chosen once on load)');
  }

  // ==================== START ====================
  
  // Initialize when DOM is ready
  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(init, 0);
  } else {
    document.addEventListener('DOMContentLoaded', init);
  }

  // Expose minimal API to update subtitle programmatically if desired
  window.BattleBros = {
    setSubtitle: (text) => { if (el.subtitle) el.subtitle.textContent = String(text); },
    setRandomSubtitleNow: () => { setInitialSubtitle(); }
  };

})();
</script>
</body>
</html>
